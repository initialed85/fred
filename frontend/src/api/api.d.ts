/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/changes": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetChanges"];
    put?: never;
    post: operations["PostChanges"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/changes/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetChange"];
    put?: never;
    post?: never;
    delete: operations["DeleteChange"];
    options?: never;
    head?: never;
    patch: operations["PatchChange"];
    trace?: never;
  };
  "/api/custom/claim-trigger-for-job-executor": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch: operations["PatchCustomClaimTriggerForJobExecutor"];
    trace?: never;
  };
  "/api/executions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetExecutions"];
    put?: never;
    post: operations["PostExecutions"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/executions/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetExecution"];
    put?: never;
    post?: never;
    delete: operations["DeleteExecution"];
    options?: never;
    head?: never;
    patch: operations["PatchExecution"];
    trace?: never;
  };
  "/api/jobs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetJobs"];
    put?: never;
    post: operations["PostJobs"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/jobs/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetJob"];
    put?: never;
    post?: never;
    delete: operations["DeleteJob"];
    options?: never;
    head?: never;
    patch: operations["PatchJob"];
    trace?: never;
  };
  "/api/outputs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetOutputs"];
    put?: never;
    post: operations["PostOutputs"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/outputs/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetOutput"];
    put?: never;
    post?: never;
    delete: operations["DeleteOutput"];
    options?: never;
    head?: never;
    patch: operations["PatchOutput"];
    trace?: never;
  };
  "/api/repositories": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetRepositories"];
    put?: never;
    post: operations["PostRepositories"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/repositories/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetRepository"];
    put?: never;
    post?: never;
    delete: operations["DeleteRepository"];
    options?: never;
    head?: never;
    patch: operations["PatchRepository"];
    trace?: never;
  };
  "/api/rule-requires-jobs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetRuleRequiresJobs"];
    put?: never;
    post: operations["PostRuleRequiresJobs"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/rule-requires-jobs/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetRuleRequiresJob"];
    put?: never;
    post?: never;
    delete: operations["DeleteRuleRequiresJob"];
    options?: never;
    head?: never;
    patch: operations["PatchRuleRequiresJob"];
    trace?: never;
  };
  "/api/rules": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetRules"];
    put?: never;
    post: operations["PostRules"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/rules/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetRule"];
    put?: never;
    post?: never;
    delete: operations["DeleteRule"];
    options?: never;
    head?: never;
    patch: operations["PatchRule"];
    trace?: never;
  };
  "/api/tasks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetTasks"];
    put?: never;
    post: operations["PostTasks"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tasks/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetTask"];
    put?: never;
    post?: never;
    delete: operations["DeleteTask"];
    options?: never;
    head?: never;
    patch: operations["PatchTask"];
    trace?: never;
  };
  "/api/trigger-has-executions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetTriggerHasExecutions"];
    put?: never;
    post: operations["PostTriggerHasExecutions"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/trigger-has-executions/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetTriggerHasExecution"];
    put?: never;
    post?: never;
    delete: operations["DeleteTriggerHasExecution"];
    options?: never;
    head?: never;
    patch: operations["PatchTriggerHasExecution"];
    trace?: never;
  };
  "/api/triggers": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetTriggers"];
    put?: never;
    post: operations["PostTriggers"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/triggers/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetTrigger"];
    put?: never;
    post?: never;
    delete: operations["DeleteTrigger"];
    options?: never;
    head?: never;
    patch: operations["PatchTrigger"];
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    ArrayOfNullableChange: components["schemas"]["Change"][] | null;
    ArrayOfNullableExecution: components["schemas"]["Execution"][] | null;
    ArrayOfNullableJob: components["schemas"]["Job"][] | null;
    ArrayOfNullableOutput: components["schemas"]["Execution"][] | null;
    ArrayOfNullableRepository: components["schemas"]["Repository"][] | null;
    ArrayOfNullableRule: components["schemas"]["Rule"][] | null;
    ArrayOfNullableRuleRequiresJob:
      | components["schemas"]["RuleRequiresJob"][]
      | null;
    ArrayOfNullableTask: components["schemas"]["Task"][] | null;
    ArrayOfNullableTrigger: components["schemas"]["Trigger"][] | null;
    ArrayOfNullableTriggerHasExecution:
      | components["schemas"]["TriggerHasExecution"][]
      | null;
    ArrayOfString: string[] | null;
    Change: {
      /** Format: date-time */
      authored_at?: string;
      authored_by?: string;
      branch_name?: string;
      commit_hash?: string;
      /** Format: date-time */
      committed_at?: string;
      committed_by?: string;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      /** Format: uuid */
      id?: string;
      message?: string;
      referenced_by_trigger_change_id_objects?:
        | components["schemas"]["Trigger"][]
        | null;
      /** Format: uuid */
      repository_id?: string;
      repository_id_object?: components["schemas"]["Repository"];
      /** Format: date-time */
      trigger_produced_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    ClaimRequest: {
      /** Format: double */
      claim_duration_seconds?: number;
    };
    Execution: {
      /** Format: uuid */
      build_output_id?: string;
      build_output_id_object?: components["schemas"]["Output"];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      /** Format: uuid */
      deploy_output_id?: string;
      deploy_output_id_object?: components["schemas"]["Output"];
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      job_id?: string;
      job_id_object?: components["schemas"]["Job"];
      /** Format: uuid */
      publish_output_id?: string;
      publish_output_id_object?: components["schemas"]["Output"];
      referenced_by_trigger_has_execution_execution_id_objects?:
        | components["schemas"]["TriggerHasExecution"][]
        | null;
      status?: string;
      /** Format: uuid */
      test_output_id?: string;
      test_output_id_object?: components["schemas"]["Output"];
      /** Format: uuid */
      trigger_id?: string;
      trigger_id_object?: components["schemas"]["Trigger"];
      /** Format: date-time */
      updated_at?: string;
      /** Format: uuid */
      validate_output_id?: string;
      validate_output_id_object?: components["schemas"]["Output"];
    };
    Job: {
      /** Format: uuid */
      build_task_id?: string;
      build_task_id_object?: components["schemas"]["Task"];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      /** Format: uuid */
      deploy_task_id?: string;
      deploy_task_id_object?: components["schemas"]["Task"];
      /** Format: uuid */
      id?: string;
      /** Format: date-time */
      job_executor_claimed_until?: string;
      name?: string;
      /** Format: uuid */
      publish_task_id?: string;
      publish_task_id_object?: components["schemas"]["Task"];
      referenced_by_execution_job_id_objects?:
        | components["schemas"]["Execution"][]
        | null;
      referenced_by_rule_requires_job_job_id_objects?:
        | components["schemas"]["RuleRequiresJob"][]
        | null;
      /** Format: uuid */
      rule_id?: string;
      rule_id_object?: components["schemas"]["Rule"];
      /** Format: uuid */
      test_task_id?: string;
      test_task_id_object?: components["schemas"]["Task"];
      /** Format: date-time */
      updated_at?: string;
      /** Format: uuid */
      validate_task_id?: string;
      validate_task_id_object?: components["schemas"]["Task"];
    };
    NullableChange: components["schemas"]["Change"];
    NullableExecution: components["schemas"]["Execution"];
    NullableJob: components["schemas"]["Job"];
    NullableOutput: components["schemas"]["Output"];
    NullableRepository: components["schemas"]["Repository"];
    NullableRule: components["schemas"]["Rule"];
    NullableRuleRequiresJob: components["schemas"]["RuleRequiresJob"];
    NullableTask: components["schemas"]["Task"];
    NullableTrigger: components["schemas"]["Trigger"];
    NullableTriggerHasExecution: components["schemas"]["TriggerHasExecution"];
    Output: {
      buffer?: string;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      error?: string;
      /** Format: int64 */
      exit_status?: number;
      /** Format: uuid */
      id?: string;
      referenced_by_execution_build_output_id_objects?:
        | components["schemas"]["Execution"][]
        | null;
      referenced_by_execution_deploy_output_id_objects?:
        | components["schemas"]["Execution"][]
        | null;
      referenced_by_execution_publish_output_id_objects?:
        | components["schemas"]["Execution"][]
        | null;
      referenced_by_execution_test_output_id_objects?:
        | components["schemas"]["Execution"][]
        | null;
      referenced_by_execution_validate_output_id_objects?:
        | components["schemas"]["Execution"][]
        | null;
      status?: string;
      /** Format: uuid */
      task_id?: string;
      task_id_object?: components["schemas"]["Task"];
      /** Format: date-time */
      updated_at?: string;
    };
    Repository: {
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      /** Format: uuid */
      id?: string;
      /** Format: date-time */
      last_synced?: string;
      password?: string;
      referenced_by_change_repository_id_objects?:
        | components["schemas"]["Change"][]
        | null;
      referenced_by_rule_repository_id_objects?:
        | components["schemas"]["Rule"][]
        | null;
      ssh_key?: string;
      /** Format: date-time */
      updated_at?: string;
      url?: string;
      username?: string;
    };
    ResponseWithGenericOfChange: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["Change"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    ResponseWithGenericOfExecution: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["Execution"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    ResponseWithGenericOfJob: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["Job"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    ResponseWithGenericOfOutput: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["Execution"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    ResponseWithGenericOfRepository: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["Repository"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    ResponseWithGenericOfRule: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["Rule"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    ResponseWithGenericOfRuleRequiresJob: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["RuleRequiresJob"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    ResponseWithGenericOfTask: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["Task"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    ResponseWithGenericOfTrigger: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["Trigger"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    ResponseWithGenericOfTriggerHasExecution: {
      /** Format: int64 */
      count?: number;
      error?: string[] | null;
      /** Format: int64 */
      limit?: number;
      objects?: components["schemas"]["TriggerHasExecution"][] | null;
      /** Format: int64 */
      offset?: number;
      /** Format: int64 */
      status?: number;
      success?: boolean;
      /** Format: int64 */
      total_count?: number;
    };
    Rule: {
      branch_name?: string;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      /** Format: uuid */
      id?: string;
      referenced_by_job_rule_id_objects?: components["schemas"]["Job"][] | null;
      referenced_by_rule_requires_job_rule_id_objects?:
        | components["schemas"]["RuleRequiresJob"][]
        | null;
      referenced_by_trigger_rule_id_objects?:
        | components["schemas"]["Trigger"][]
        | null;
      /** Format: uuid */
      repository_id?: string;
      repository_id_object?: components["schemas"]["Repository"];
      /** Format: date-time */
      updated_at?: string;
    };
    RuleRequiresJob: {
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      job_id?: string;
      job_id_object?: components["schemas"]["Job"];
      /** Format: uuid */
      rule_id?: string;
      rule_id_object?: components["schemas"]["Rule"];
      /** Format: date-time */
      updated_at?: string;
    };
    Task: {
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      /** Format: uuid */
      id?: string;
      image?: string;
      name?: string;
      platform?: string;
      referenced_by_job_build_task_id_objects?:
        | components["schemas"]["Job"][]
        | null;
      referenced_by_job_deploy_task_id_objects?:
        | components["schemas"]["Job"][]
        | null;
      referenced_by_job_publish_task_id_objects?:
        | components["schemas"]["Job"][]
        | null;
      referenced_by_job_test_task_id_objects?:
        | components["schemas"]["Job"][]
        | null;
      referenced_by_job_validate_task_id_objects?:
        | components["schemas"]["Job"][]
        | null;
      referenced_by_output_task_id_objects?:
        | components["schemas"]["Execution"][]
        | null;
      script?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    Trigger: {
      /** Format: uuid */
      change_id?: string;
      change_id_object?: components["schemas"]["Change"];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      /** Format: uuid */
      id?: string;
      /** Format: date-time */
      job_execution_started_at?: string;
      /** Format: date-time */
      job_executor_claimed_until?: string;
      referenced_by_execution_trigger_id_objects?:
        | components["schemas"]["Execution"][]
        | null;
      referenced_by_trigger_has_execution_trigger_id_objects?:
        | components["schemas"]["TriggerHasExecution"][]
        | null;
      /** Format: uuid */
      rule_id?: string;
      rule_id_object?: components["schemas"]["Rule"];
      /** Format: date-time */
      updated_at?: string;
    };
    TriggerHasExecution: {
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string;
      /** Format: uuid */
      execution_id?: string;
      execution_id_object?: components["schemas"]["Execution"];
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      trigger_id?: string;
      trigger_id_object?: components["schemas"]["Trigger"];
      /** Format: date-time */
      updated_at?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  GetChanges: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        branch_name__eq?: string;
        /** @description SQL != comparison */
        branch_name__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        branch_name__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        branch_name__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        branch_name__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        branch_name__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        branch_name__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        branch_name__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        branch_name__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        branch_name__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        branch_name__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        branch_name__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        branch_name__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        branch_name__asc?: string;
        /** @description SQL = comparison */
        commit_hash__eq?: string;
        /** @description SQL != comparison */
        commit_hash__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        commit_hash__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        commit_hash__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        commit_hash__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        commit_hash__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        commit_hash__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        commit_hash__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        commit_hash__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        commit_hash__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        commit_hash__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        commit_hash__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        commit_hash__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        commit_hash__asc?: string;
        /** @description SQL = comparison */
        message__eq?: string;
        /** @description SQL != comparison */
        message__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        message__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        message__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        message__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        message__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        message__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        message__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        message__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        message__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        message__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        message__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        message__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        message__asc?: string;
        /** @description SQL = comparison */
        authored_by__eq?: string;
        /** @description SQL != comparison */
        authored_by__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        authored_by__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        authored_by__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        authored_by__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        authored_by__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        authored_by__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        authored_by__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        authored_by__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        authored_by__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        authored_by__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        authored_by__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        authored_by__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        authored_by__asc?: string;
        /** @description SQL = comparison */
        authored_at__eq?: string;
        /** @description SQL != comparison */
        authored_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        authored_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        authored_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        authored_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        authored_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        authored_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        authored_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        authored_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        authored_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        authored_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        authored_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        authored_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        authored_at__asc?: string;
        /** @description SQL = comparison */
        committed_by__eq?: string;
        /** @description SQL != comparison */
        committed_by__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        committed_by__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        committed_by__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        committed_by__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        committed_by__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        committed_by__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        committed_by__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        committed_by__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        committed_by__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        committed_by__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        committed_by__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        committed_by__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        committed_by__asc?: string;
        /** @description SQL = comparison */
        committed_at__eq?: string;
        /** @description SQL != comparison */
        committed_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        committed_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        committed_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        committed_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        committed_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        committed_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        committed_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        committed_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        committed_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        committed_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        committed_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        committed_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        committed_at__asc?: string;
        /** @description SQL = comparison */
        trigger_produced_at__eq?: string;
        /** @description SQL != comparison */
        trigger_produced_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        trigger_produced_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        trigger_produced_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        trigger_produced_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        trigger_produced_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        trigger_produced_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        trigger_produced_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_produced_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_produced_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_produced_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_produced_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        trigger_produced_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        trigger_produced_at__asc?: string;
        /** @description SQL = comparison */
        repository_id__eq?: string;
        /** @description SQL != comparison */
        repository_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        repository_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        repository_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        repository_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        repository_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        repository_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        repository_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        repository_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        repository_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        repository_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        repository_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        repository_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        repository_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        repository_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        repository_id_object__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_trigger_change_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_trigger_change_id_objects__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetChanges success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfChange"];
        };
      };
      /** @description GetChanges failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostChanges: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableChange"];
      };
    };
    responses: {
      /** @description PostChanges success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfChange"];
        };
      };
      /** @description PostChanges failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetChange: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetChange success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfChange"];
        };
      };
      /** @description GetChange failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteChange: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteChange success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteChange failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchChange: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Change"];
      };
    };
    responses: {
      /** @description PatchChange success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfChange"];
        };
      };
      /** @description PatchChange failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PatchCustomClaimTriggerForJobExecutor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ClaimRequest"];
      };
    };
    responses: {
      /** @description PatchCustomClaimTriggerForJobExecutor success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["NullableTrigger"];
        };
      };
      /** @description PatchCustomClaimTriggerForJobExecutor failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetExecutions: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        status__eq?: string;
        /** @description SQL != comparison */
        status__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        status__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        status__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        status__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        status__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        status__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        status__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        status__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        status__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        status__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        status__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        status__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        status__asc?: string;
        /** @description SQL = comparison */
        trigger_id__eq?: string;
        /** @description SQL != comparison */
        trigger_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        trigger_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        trigger_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        trigger_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        trigger_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        trigger_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        trigger_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        trigger_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        trigger_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        trigger_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        trigger_id_object__asc?: string;
        /** @description SQL = comparison */
        build_output_id__eq?: string;
        /** @description SQL != comparison */
        build_output_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        build_output_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        build_output_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        build_output_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        build_output_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        build_output_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        build_output_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        build_output_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        build_output_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        build_output_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        build_output_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        build_output_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        build_output_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        build_output_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        build_output_id_object__asc?: string;
        /** @description SQL = comparison */
        test_output_id__eq?: string;
        /** @description SQL != comparison */
        test_output_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        test_output_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        test_output_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        test_output_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        test_output_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        test_output_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        test_output_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        test_output_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        test_output_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        test_output_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        test_output_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        test_output_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        test_output_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        test_output_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        test_output_id_object__asc?: string;
        /** @description SQL = comparison */
        publish_output_id__eq?: string;
        /** @description SQL != comparison */
        publish_output_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        publish_output_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        publish_output_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        publish_output_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        publish_output_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        publish_output_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        publish_output_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        publish_output_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        publish_output_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        publish_output_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        publish_output_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        publish_output_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        publish_output_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        publish_output_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        publish_output_id_object__asc?: string;
        /** @description SQL = comparison */
        deploy_output_id__eq?: string;
        /** @description SQL != comparison */
        deploy_output_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deploy_output_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deploy_output_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deploy_output_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deploy_output_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deploy_output_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deploy_output_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deploy_output_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deploy_output_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deploy_output_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deploy_output_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deploy_output_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deploy_output_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deploy_output_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deploy_output_id_object__asc?: string;
        /** @description SQL = comparison */
        validate_output_id__eq?: string;
        /** @description SQL != comparison */
        validate_output_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        validate_output_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        validate_output_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        validate_output_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        validate_output_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        validate_output_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        validate_output_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        validate_output_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        validate_output_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        validate_output_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        validate_output_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        validate_output_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        validate_output_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        validate_output_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        validate_output_id_object__asc?: string;
        /** @description SQL = comparison */
        job_id__eq?: string;
        /** @description SQL != comparison */
        job_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        job_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        job_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        job_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        job_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        job_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        job_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        job_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        job_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        job_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        job_id_object__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_trigger_has_execution_execution_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_trigger_has_execution_execution_id_objects__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetExecutions success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfExecution"];
        };
      };
      /** @description GetExecutions failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostExecutions: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableExecution"];
      };
    };
    responses: {
      /** @description PostExecutions success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfExecution"];
        };
      };
      /** @description PostExecutions failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetExecution: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetExecution success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfExecution"];
        };
      };
      /** @description GetExecution failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteExecution: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteExecution success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteExecution failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchExecution: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Execution"];
      };
    };
    responses: {
      /** @description PatchExecution success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfExecution"];
        };
      };
      /** @description PatchExecution failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetJobs: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        name__eq?: string;
        /** @description SQL != comparison */
        name__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        name__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        name__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        name__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        name__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        name__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        name__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        name__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        name__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        name__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        name__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        name__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        name__asc?: string;
        /** @description SQL = comparison */
        job_executor_claimed_until__eq?: string;
        /** @description SQL != comparison */
        job_executor_claimed_until__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        job_executor_claimed_until__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        job_executor_claimed_until__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        job_executor_claimed_until__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        job_executor_claimed_until__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        job_executor_claimed_until__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        job_executor_claimed_until__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_executor_claimed_until__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_executor_claimed_until__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_executor_claimed_until__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_executor_claimed_until__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        job_executor_claimed_until__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        job_executor_claimed_until__asc?: string;
        /** @description SQL = comparison */
        rule_id__eq?: string;
        /** @description SQL != comparison */
        rule_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        rule_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        rule_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        rule_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        rule_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        rule_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        rule_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        rule_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        rule_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        rule_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        rule_id_object__asc?: string;
        /** @description SQL = comparison */
        build_task_id__eq?: string;
        /** @description SQL != comparison */
        build_task_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        build_task_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        build_task_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        build_task_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        build_task_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        build_task_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        build_task_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        build_task_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        build_task_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        build_task_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        build_task_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        build_task_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        build_task_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        build_task_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        build_task_id_object__asc?: string;
        /** @description SQL = comparison */
        test_task_id__eq?: string;
        /** @description SQL != comparison */
        test_task_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        test_task_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        test_task_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        test_task_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        test_task_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        test_task_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        test_task_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        test_task_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        test_task_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        test_task_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        test_task_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        test_task_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        test_task_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        test_task_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        test_task_id_object__asc?: string;
        /** @description SQL = comparison */
        publish_task_id__eq?: string;
        /** @description SQL != comparison */
        publish_task_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        publish_task_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        publish_task_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        publish_task_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        publish_task_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        publish_task_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        publish_task_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        publish_task_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        publish_task_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        publish_task_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        publish_task_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        publish_task_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        publish_task_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        publish_task_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        publish_task_id_object__asc?: string;
        /** @description SQL = comparison */
        deploy_task_id__eq?: string;
        /** @description SQL != comparison */
        deploy_task_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deploy_task_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deploy_task_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deploy_task_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deploy_task_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deploy_task_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deploy_task_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deploy_task_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deploy_task_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deploy_task_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deploy_task_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deploy_task_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deploy_task_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deploy_task_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deploy_task_id_object__asc?: string;
        /** @description SQL = comparison */
        validate_task_id__eq?: string;
        /** @description SQL != comparison */
        validate_task_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        validate_task_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        validate_task_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        validate_task_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        validate_task_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        validate_task_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        validate_task_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        validate_task_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        validate_task_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        validate_task_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        validate_task_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        validate_task_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        validate_task_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        validate_task_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        validate_task_id_object__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_rule_requires_job_job_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_rule_requires_job_job_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_job_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_job_id_objects__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetJobs success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfJob"];
        };
      };
      /** @description GetJobs failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostJobs: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableJob"];
      };
    };
    responses: {
      /** @description PostJobs success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfJob"];
        };
      };
      /** @description PostJobs failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetJob: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetJob success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfJob"];
        };
      };
      /** @description GetJob failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteJob: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteJob success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteJob failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchJob: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Job"];
      };
    };
    responses: {
      /** @description PatchJob success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfJob"];
        };
      };
      /** @description PatchJob failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetOutputs: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        status__eq?: string;
        /** @description SQL != comparison */
        status__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        status__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        status__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        status__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        status__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        status__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        status__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        status__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        status__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        status__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        status__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        status__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        status__asc?: string;
        /** @description SQL = comparison */
        exit_status__eq?: number;
        /** @description SQL != comparison */
        exit_status__ne?: number;
        /** @description SQL > comparison, may not work with all column types */
        exit_status__gt?: number;
        /** @description SQL >= comparison, may not work with all column types */
        exit_status__gte?: number;
        /** @description SQL < comparison, may not work with all column types */
        exit_status__lt?: number;
        /** @description SQL <= comparison, may not work with all column types */
        exit_status__lte?: number;
        /** @description SQL IN comparison, permits comma-separated values */
        exit_status__in?: number;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        exit_status__notin?: number;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        exit_status__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        exit_status__asc?: string;
        /** @description SQL = comparison */
        buffer__eq?: string;
        /** @description SQL != comparison */
        buffer__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        buffer__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        buffer__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        buffer__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        buffer__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        buffer__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        buffer__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        buffer__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        buffer__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        buffer__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        buffer__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        buffer__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        buffer__asc?: string;
        /** @description SQL = comparison */
        error__eq?: string;
        /** @description SQL != comparison */
        error__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        error__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        error__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        error__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        error__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        error__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        error__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        error__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        error__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        error__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        error__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        error__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        error__asc?: string;
        /** @description SQL = comparison */
        task_id__eq?: string;
        /** @description SQL != comparison */
        task_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        task_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        task_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        task_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        task_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        task_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        task_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        task_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        task_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        task_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        task_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        task_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        task_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        task_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        task_id_object__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_build_output_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_build_output_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_test_output_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_test_output_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_publish_output_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_publish_output_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_deploy_output_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_deploy_output_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_validate_output_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_validate_output_id_objects__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetOutputs success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfOutput"];
        };
      };
      /** @description GetOutputs failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostOutputs: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableOutput"];
      };
    };
    responses: {
      /** @description PostOutputs success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfOutput"];
        };
      };
      /** @description PostOutputs failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetOutput: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetOutput success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfOutput"];
        };
      };
      /** @description GetOutput failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteOutput: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteOutput success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteOutput failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchOutput: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Output"];
      };
    };
    responses: {
      /** @description PatchOutput success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfOutput"];
        };
      };
      /** @description PatchOutput failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetRepositories: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        last_synced__eq?: string;
        /** @description SQL != comparison */
        last_synced__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        last_synced__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        last_synced__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        last_synced__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        last_synced__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        last_synced__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        last_synced__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        last_synced__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        last_synced__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        last_synced__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        last_synced__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        last_synced__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        last_synced__asc?: string;
        /** @description SQL = comparison */
        url__eq?: string;
        /** @description SQL != comparison */
        url__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        url__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        url__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        url__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        url__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        url__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        url__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        url__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        url__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        url__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        url__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        url__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        url__asc?: string;
        /** @description SQL = comparison */
        username__eq?: string;
        /** @description SQL != comparison */
        username__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        username__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        username__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        username__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        username__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        username__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        username__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        username__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        username__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        username__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        username__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        username__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        username__asc?: string;
        /** @description SQL = comparison */
        password__eq?: string;
        /** @description SQL != comparison */
        password__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        password__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        password__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        password__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        password__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        password__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        password__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        password__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        password__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        password__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        password__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        password__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        password__asc?: string;
        /** @description SQL = comparison */
        ssh_key__eq?: string;
        /** @description SQL != comparison */
        ssh_key__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        ssh_key__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        ssh_key__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        ssh_key__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        ssh_key__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        ssh_key__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        ssh_key__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        ssh_key__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        ssh_key__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        ssh_key__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        ssh_key__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        ssh_key__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        ssh_key__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_rule_repository_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_rule_repository_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_change_repository_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_change_repository_id_objects__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetRepositories success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRepository"];
        };
      };
      /** @description GetRepositories failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostRepositories: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableRepository"];
      };
    };
    responses: {
      /** @description PostRepositories success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRepository"];
        };
      };
      /** @description PostRepositories failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetRepository: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetRepository success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRepository"];
        };
      };
      /** @description GetRepository failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteRepository: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteRepository success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteRepository failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchRepository: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Repository"];
      };
    };
    responses: {
      /** @description PatchRepository success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRepository"];
        };
      };
      /** @description PatchRepository failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetRuleRequiresJobs: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        rule_id__eq?: string;
        /** @description SQL != comparison */
        rule_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        rule_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        rule_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        rule_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        rule_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        rule_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        rule_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        rule_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        rule_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        rule_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        rule_id_object__asc?: string;
        /** @description SQL = comparison */
        job_id__eq?: string;
        /** @description SQL != comparison */
        job_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        job_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        job_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        job_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        job_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        job_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        job_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        job_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        job_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        job_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        job_id_object__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetRuleRequiresJobs success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRuleRequiresJob"];
        };
      };
      /** @description GetRuleRequiresJobs failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostRuleRequiresJobs: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableRuleRequiresJob"];
      };
    };
    responses: {
      /** @description PostRuleRequiresJobs success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRuleRequiresJob"];
        };
      };
      /** @description PostRuleRequiresJobs failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetRuleRequiresJob: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetRuleRequiresJob success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRuleRequiresJob"];
        };
      };
      /** @description GetRuleRequiresJob failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteRuleRequiresJob: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteRuleRequiresJob success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteRuleRequiresJob failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchRuleRequiresJob: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RuleRequiresJob"];
      };
    };
    responses: {
      /** @description PatchRuleRequiresJob success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRuleRequiresJob"];
        };
      };
      /** @description PatchRuleRequiresJob failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetRules: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        branch_name__eq?: string;
        /** @description SQL != comparison */
        branch_name__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        branch_name__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        branch_name__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        branch_name__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        branch_name__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        branch_name__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        branch_name__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        branch_name__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        branch_name__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        branch_name__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        branch_name__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        branch_name__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        branch_name__asc?: string;
        /** @description SQL = comparison */
        repository_id__eq?: string;
        /** @description SQL != comparison */
        repository_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        repository_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        repository_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        repository_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        repository_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        repository_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        repository_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        repository_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        repository_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        repository_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        repository_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        repository_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        repository_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        repository_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        repository_id_object__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_rule_requires_job_rule_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_rule_requires_job_rule_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_trigger_rule_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_trigger_rule_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_rule_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_rule_id_objects__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetRules success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRule"];
        };
      };
      /** @description GetRules failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostRules: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableRule"];
      };
    };
    responses: {
      /** @description PostRules success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRule"];
        };
      };
      /** @description PostRules failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetRule: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetRule success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRule"];
        };
      };
      /** @description GetRule failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteRule: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteRule success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteRule failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchRule: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Rule"];
      };
    };
    responses: {
      /** @description PatchRule success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfRule"];
        };
      };
      /** @description PatchRule failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetTasks: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        name__eq?: string;
        /** @description SQL != comparison */
        name__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        name__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        name__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        name__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        name__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        name__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        name__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        name__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        name__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        name__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        name__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        name__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        name__asc?: string;
        /** @description SQL = comparison */
        platform__eq?: string;
        /** @description SQL != comparison */
        platform__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        platform__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        platform__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        platform__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        platform__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        platform__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        platform__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        platform__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        platform__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        platform__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        platform__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        platform__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        platform__asc?: string;
        /** @description SQL = comparison */
        image__eq?: string;
        /** @description SQL != comparison */
        image__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        image__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        image__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        image__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        image__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        image__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        image__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        image__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        image__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        image__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        image__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        image__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        image__asc?: string;
        /** @description SQL = comparison */
        script__eq?: string;
        /** @description SQL != comparison */
        script__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        script__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        script__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        script__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        script__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        script__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        script__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        script__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        script__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        script__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        script__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        script__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        script__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_build_task_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_build_task_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_test_task_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_test_task_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_publish_task_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_publish_task_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_deploy_task_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_deploy_task_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_validate_task_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_job_validate_task_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_output_task_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_output_task_id_objects__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetTasks success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTask"];
        };
      };
      /** @description GetTasks failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostTasks: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableTask"];
      };
    };
    responses: {
      /** @description PostTasks success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTask"];
        };
      };
      /** @description PostTasks failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetTask: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetTask success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTask"];
        };
      };
      /** @description GetTask failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteTask: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteTask success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteTask failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchTask: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Task"];
      };
    };
    responses: {
      /** @description PatchTask success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTask"];
        };
      };
      /** @description PatchTask failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetTriggerHasExecutions: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        trigger_id__eq?: string;
        /** @description SQL != comparison */
        trigger_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        trigger_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        trigger_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        trigger_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        trigger_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        trigger_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        trigger_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        trigger_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        trigger_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        trigger_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        trigger_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        trigger_id_object__asc?: string;
        /** @description SQL = comparison */
        execution_id__eq?: string;
        /** @description SQL != comparison */
        execution_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        execution_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        execution_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        execution_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        execution_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        execution_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        execution_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        execution_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        execution_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        execution_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        execution_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        execution_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        execution_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        execution_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        execution_id_object__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetTriggerHasExecutions success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTriggerHasExecution"];
        };
      };
      /** @description GetTriggerHasExecutions failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostTriggerHasExecutions: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableTriggerHasExecution"];
      };
    };
    responses: {
      /** @description PostTriggerHasExecutions success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTriggerHasExecution"];
        };
      };
      /** @description PostTriggerHasExecutions failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetTriggerHasExecution: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetTriggerHasExecution success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTriggerHasExecution"];
        };
      };
      /** @description GetTriggerHasExecution failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteTriggerHasExecution: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteTriggerHasExecution success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteTriggerHasExecution failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchTriggerHasExecution: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TriggerHasExecution"];
      };
    };
    responses: {
      /** @description PatchTriggerHasExecution success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTriggerHasExecution"];
        };
      };
      /** @description PatchTriggerHasExecution failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetTriggers: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        job_executor_claimed_until__eq?: string;
        /** @description SQL != comparison */
        job_executor_claimed_until__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        job_executor_claimed_until__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        job_executor_claimed_until__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        job_executor_claimed_until__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        job_executor_claimed_until__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        job_executor_claimed_until__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        job_executor_claimed_until__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_executor_claimed_until__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_executor_claimed_until__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_executor_claimed_until__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_executor_claimed_until__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        job_executor_claimed_until__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        job_executor_claimed_until__asc?: string;
        /** @description SQL = comparison */
        job_execution_started_at__eq?: string;
        /** @description SQL != comparison */
        job_execution_started_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        job_execution_started_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        job_execution_started_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        job_execution_started_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        job_execution_started_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        job_execution_started_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        job_execution_started_at__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_execution_started_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        job_execution_started_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_execution_started_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        job_execution_started_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        job_execution_started_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        job_execution_started_at__asc?: string;
        /** @description SQL = comparison */
        rule_id__eq?: string;
        /** @description SQL != comparison */
        rule_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        rule_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        rule_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        rule_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        rule_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        rule_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        rule_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        rule_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        rule_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        rule_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        rule_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        rule_id_object__asc?: string;
        /** @description SQL = comparison */
        change_id__eq?: string;
        /** @description SQL != comparison */
        change_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        change_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        change_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        change_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        change_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        change_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        change_id__notin?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        change_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        change_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        change_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        change_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        change_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        change_id__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        change_id_object__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        change_id_object__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_trigger_has_execution_trigger_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_trigger_has_execution_trigger_id_objects__asc?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_trigger_id_objects__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        referenced_by_execution_trigger_id_objects__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetTriggers success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTrigger"];
        };
      };
      /** @description GetTriggers failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostTriggers: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArrayOfNullableTrigger"];
      };
    };
    responses: {
      /** @description PostTriggers success */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTrigger"];
        };
      };
      /** @description PostTriggers failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetTrigger: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description GetTrigger success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTrigger"];
        };
      };
      /** @description GetTrigger failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteTrigger: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DeleteTrigger success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description DeleteTrigger failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PatchTrigger: {
    parameters: {
      query?: {
        /** @description Query parameter depth */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Path parameter primaryKey */
        primaryKey: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Trigger"];
      };
    };
    responses: {
      /** @description PatchTrigger success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ResponseWithGenericOfTrigger"];
        };
      };
      /** @description PatchTrigger failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
}
